<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>MP Voting System with Staking</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/web3/1.10.0/web3.min.js"></script>

</head>
<body>
    <div>
        <h1>MP Voting System with Staking</h1>
        
        <div>
            <h2>Connection Status</h2>
            <div id="connectionStatus">Disconnected</div>
            <button onclick="connectWallet()">Connect Wallet</button>
            <button onclick="switchToAnvil()">Switch to Anvil</button>
            <div>
                <label>Account: </label>
                <span id="currentAccount">Not connected</span>
            </div>
            <div>
                <label>Balance: </label>
                <span id="accountBalance">0 ETH</span>
            </div>
            <div>
                <label>Blockchain Time: </label>
                <span id="blockchainTime">Not connected</span>
                <button onclick="updateBlockchainTime()">Refresh Time</button>
            </div>
        </div>

        <div>
            <h2>Contract Configuration</h2>
            <div>
                <label>MP Token Factory Address:</label>
                <input type="text" id="factoryAddress" placeholder="0x..." value="0x5fbdb2315678afecb367f032d93f642f64180aa3" style="width: 400px;">
            </div>
            <div>
                <label>MP Voting Contract Address:</label>
                <input type="text" id="votingAddress" placeholder="0x..." value="0xe7f1725e7734ce288f8367e1bb143e90bb3f0512" style="width: 400px;">
            </div>
            <button onclick="initializeContracts()">Initialize Contracts</button>
            <div id="contractStatus"></div>
        </div>

        <div>
            <h2>Admin Functions</h2>
            <div id="adminStatus"></div>
            
            <h3>Create MP Token</h3>
            <div>
                <div>
                    <input type="text" id="mpRecipient" placeholder="Recipient Address" style="width: 100%;">
                </div>
                <div>
                    <input type="text" id="mpName" placeholder="MP Name" style="width: 100%;">
                </div>
                <div>
                    <input type="text" id="mpParty" placeholder="Political Party" style="width: 100%;">
                </div>
                <div>
                    <input type="text" id="mpConstituency" placeholder="Constituency" style="width: 100%;">
                </div>
                <button onclick="createMPToken()">Create MP Token</button>
            </div>

            <h3>Manage MP Tokens</h3>
            <div style="border: 1px solid #ddd; padding: 15px; margin: 15px 0; border-radius: 6px; background-color: #f9f9f9;">
                <h4>Destroy Expired MP Token</h4>
                <div>
                    <input type="number" id="tokenIdToDestroy" placeholder="Token ID to destroy" min="1" style="width: 200px;">
                    <button onclick="checkTokenExpiry()">Check if Expired</button>
                    <button onclick="destroyExpiredToken()" style="background: #dc3545;">Destroy Expired Token</button>
                </div>
                <div id="tokenExpiryStatus" style="margin-top: 10px; padding: 10px; background-color: #f0f0f0; border-radius: 4px;"></div>
                
                <h4>Update MP Token Status</h4>
                <div>
                    <input type="number" id="tokenIdToUpdate" placeholder="Token ID" min="1" style="width: 150px;">
                    <select id="tokenStatus">
                        <option value="true">Active</option>
                        <option value="false">Inactive</option>
                    </select>
                    <button onclick="updateMPTokenStatus()">Update Status</button>
                </div>
            </div>

            <h3>Create Voting Question</h3>
            <div>
                <div>
                    <textarea id="questionText" placeholder="Enter your question..." style="width: 100%; height: 60px;"></textarea>
                </div>
                <div>
                    <label>Start Time:</label>
                    <input type="datetime-local" id="startTime">
                    <button onclick="setStartTimeNow()">Set to Now (+2 min)</button>
                </div>
                <div>
                    <label>End Time:</label>
                    <input type="datetime-local" id="endTime">
                    <button onclick="setEndTime()">Set to +10 min from start</button>
                </div>
                <div style="margin: 10px 0; padding: 10px; border: 1px solid #ccc; border-radius: 4px;">
                    <strong>Current Blockchain Time:</strong> <span id="currentBlockchainTime">Loading...</span>
                    <button onclick="getBlockchainTimestamp()">Refresh</button>
                    <button onclick="testTimeValidation()">Test Time Validation</button>
                </div>
                <button onclick="createQuestion()">Create Question (Vault Owner)</button>
            </div>
            
            <h3>Manage Questions</h3>
            <div>
                <div>
                    <label>Question ID:</label>
                    <input type="number" id="questionIdToClose" placeholder="Question ID" min="1">
                    <button onclick="closeQuestion()">Close Question</button>
                    <button onclick="settleStakes()">Settle Stakes</button>
                </div>
            </div>
            
            <h3>Admin Management</h3>
            <div>
                <div>
                    <input type="text" id="adminAddress" placeholder="Admin Address" style="width: 300px;">
                    <button onclick="addAdmin()">Add Admin</button>
                    <button onclick="removeAdmin()">Remove Admin</button>
                </div>
            </div>
        </div>

        <div>
            <h2>MP Dashboard</h2>
            <div id="mpStatus"></div>
            <button onclick="loadMPTokens()">Refresh My MP Tokens</button>
            <div id="myMPTokens"></div>
        </div>

        <div>
            <h2>Active Voting (with Staking)</h2>
            <button onclick="loadActiveQuestions()">Refresh Active Questions</button>
            <div id="activeQuestions"></div>
        </div>

        <div>
            <h2>Stake Management</h2>
            <button onclick="loadMyStakes()">Check My Stakes</button>
            <div id="myStakes"></div>
        </div>

        <div>
            <h2>Voting Results & History</h2>
            <button onclick="loadAllQuestions()">Load All Questions</button>
            <div id="allQuestions"></div>
        </div>

        <div>
            <h2>All MPs Directory</h2>
            <button onclick="loadAllMPs()">Load All MPs</button>
            <div id="allMPs"></div>
        </div>

        <div id="messages"></div>
    </div>

    <script>
        let web3;
        let currentAccount;
        let mpTokenFactory;
        let mpVoting;
        let mpToken;

        const MP_TOKEN_FACTORY_ABI = [
            {
                "inputs": [],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "admin",
                        "type": "address"
                    }
                ],
                "name": "AdminAdded",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "admin",
                        "type": "address"
                    }
                ],
                "name": "AdminRemoved",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "ExpiredMPTokenDestroyed",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "mpTokenAddress",
                        "type": "address"
                    }
                ],
                "name": "MPTokenFactoryDeployed",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "name",
                        "type": "string"
                    },
                    {
                        "indexed": false,
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "expirationDate",
                        "type": "uint256"
                    }
                ],
                "name": "NewMPTokenMinted",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "previousAdminRole",
                        "type": "bytes32"
                    },
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "newAdminRole",
                        "type": "bytes32"
                    }
                ],
                "name": "RoleAdminChanged",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "sender",
                        "type": "address"
                    }
                ],
                "name": "RoleGranted",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "sender",
                        "type": "address"
                    }
                ],
                "name": "RoleRevoked",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "ADMIN_ROLE",
                "outputs": [
                    {
                        "internalType": "bytes32",
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "DEFAULT_ADMIN_ROLE",
                "outputs": [
                    {
                        "internalType": "bytes32",
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "admin",
                        "type": "address"
                    }
                ],
                "name": "addAdmin",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "recipient",
                        "type": "address"
                    },
                    {
                        "internalType": "string",
                        "name": "name",
                        "type": "string"
                    },
                    {
                        "internalType": "string",
                        "name": "party",
                        "type": "string"
                    },
                    {
                        "internalType": "string",
                        "name": "constituency",
                        "type": "string"
                    },
                    {
                        "internalType": "uint256",
                        "name": "electionYear",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "expirationDate",
                        "type": "uint256"
                    }
                ],
                "name": "createMPToken",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "destroyExpiredMPToken",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "getMPTokenData",
                "outputs": [
                    {
                        "components": [
                            {
                                "internalType": "string",
                                "name": "name",
                                "type": "string"
                            },
                            {
                                "internalType": "string",
                                "name": "party",
                                "type": "string"
                            },
                            {
                                "internalType": "string",
                                "name": "constituency",
                                "type": "string"
                            },
                            {
                                "internalType": "uint256",
                                "name": "electionYear",
                                "type": "uint256"
                            },
                            {
                                "internalType": "bool",
                                "name": "isActive",
                                "type": "bool"
                            },
                            {
                                "internalType": "uint256",
                                "name": "expirationDate",
                                "type": "uint256"
                            }
                        ],
                        "internalType": "struct MPToken.MPData",
                        "name": "",
                        "type": "tuple"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getMPTokenAddress",
                "outputs": [
                    {
                        "internalType": "address",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getMPTokenCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    }
                ],
                "name": "getRoleAdmin",
                "outputs": [
                    {
                        "internalType": "bytes32",
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "grantRole",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "hasRole",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "isAdmin",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    }
                ],
                "name": "isTokenExpired",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "mpToken",
                "outputs": [
                    {
                        "internalType": "contract MPToken",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "admin",
                        "type": "address"
                    }
                ],
                "name": "removeAdmin",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "renounceRole",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "revokeRole",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes4",
                        "name": "interfaceId",
                        "type": "bytes4"
                    }
                ],
                "name": "supportsInterface",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "tokenId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "isActive",
                        "type": "bool"
                    }
                ],
                "name": "updateMPTokenStatus",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            }
        ];

        const MP_VOTING_ABI = [
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_mpTokenFactoryAddress",
                        "type": "address"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "constructor"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "questionId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "totalVotes",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "winningOption",
                        "type": "uint256"
                    }
                ],
                "name": "QuestionClosed",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "questionId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "question",
                        "type": "string"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "startTime",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "endTime",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "address",
                        "name": "vault",
                        "type": "address"
                    }
                ],
                "name": "QuestionCreated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "questionId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "totalDistributed",
                        "type": "uint256"
                    }
                ],
                "name": "QuestionSettled",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "questionId",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "string",
                        "name": "question",
                        "type": "string"
                    },
                    {
                        "indexed": false,
                        "internalType": "bool",
                        "name": "isActive",
                        "type": "bool"
                    }
                ],
                "name": "QuestionUpdated",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "previousAdminRole",
                        "type": "bytes32"
                    },
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "newAdminRole",
                        "type": "bytes32"
                    }
                ],
                "name": "RoleAdminChanged",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "sender",
                        "type": "address"
                    }
                ],
                "name": "RoleGranted",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "sender",
                        "type": "address"
                    }
                ],
                "name": "RoleRevoked",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "questionId",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "voter",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "StakeReturned",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "questionId",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "vault",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "amount",
                        "type": "uint256"
                    }
                ],
                "name": "VaultEarnings",
                "type": "event"
            },
            {
                "anonymous": false,
                "inputs": [
                    {
                        "indexed": true,
                        "internalType": "uint256",
                        "name": "questionId",
                        "type": "uint256"
                    },
                    {
                        "indexed": true,
                        "internalType": "address",
                        "name": "voter",
                        "type": "address"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "option",
                        "type": "uint256"
                    },
                    {
                        "indexed": false,
                        "internalType": "uint256",
                        "name": "stake",
                        "type": "uint256"
                    }
                ],
                "name": "VoteCast",
                "type": "event"
            },
            {
                "inputs": [],
                "name": "ADMIN_ROLE",
                "outputs": [
                    {
                        "internalType": "bytes32",
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "DEFAULT_ADMIN_ROLE",
                "outputs": [
                    {
                        "internalType": "bytes32",
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "LOSER_RETURN_PERCENTAGE",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "STAKE_AMOUNT",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "admin",
                        "type": "address"
                    }
                ],
                "name": "addAdmin",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "_voter",
                        "type": "address"
                    }
                ],
                "name": "checkVote",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "hasVoted",
                        "type": "bool"
                    },
                    {
                        "internalType": "uint256",
                        "name": "optionIndex",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    }
                ],
                "name": "claimStake",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    }
                ],
                "name": "closeQuestion",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "string",
                        "name": "_question",
                        "type": "string"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_startTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_endTime",
                        "type": "uint256"
                    }
                ],
                "name": "createQuestion",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "emergencyWithdraw",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "getActiveQuestions",
                "outputs": [
                    {
                        "internalType": "uint256[]",
                        "name": "activeQuestionIds",
                        "type": "uint256[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    }
                ],
                "name": "getAllVoteCounts",
                "outputs": [
                    {
                        "internalType": "uint256[]",
                        "name": "voteCounts",
                        "type": "uint256[]"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    }
                ],
                "name": "getNoVotesCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "no_counts",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_optionIndex",
                        "type": "uint256"
                    }
                ],
                "name": "getOptionVoteCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "voteCount",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    }
                ],
                "name": "getQuestionDetails",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "question",
                        "type": "string"
                    },
                    {
                        "internalType": "string[]",
                        "name": "options",
                        "type": "string[]"
                    },
                    {
                        "internalType": "uint256",
                        "name": "startTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "endTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "isActive",
                        "type": "bool"
                    },
                    {
                        "internalType": "uint256",
                        "name": "totalVotes",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "vault",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "totalStaked",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "winningOption",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    }
                ],
                "name": "getRoleAdmin",
                "outputs": [
                    {
                        "internalType": "bytes32",
                        "name": "",
                        "type": "bytes32"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "_voter",
                        "type": "address"
                    }
                ],
                "name": "getStakeInfo",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "staked",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "returned",
                        "type": "bool"
                    },
                    {
                        "internalType": "bool",
                        "name": "canClaim",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    }
                ],
                "name": "getVotingResults",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "results",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    }
                ],
                "name": "getYesVotesCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "yes_counts",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "grantRole",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "hasRole",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "isAdmin",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "_voter",
                        "type": "address"
                    }
                ],
                "name": "isValidMPVoter",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "isValid",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "mpToken",
                "outputs": [
                    {
                        "internalType": "contract MPToken",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "mpTokenFactory",
                "outputs": [
                    {
                        "internalType": "contract MPTokenFactory",
                        "name": "",
                        "type": "address"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [],
                "name": "questionCount",
                "outputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "",
                        "type": "uint256"
                    }
                ],
                "name": "questions",
                "outputs": [
                    {
                        "internalType": "string",
                        "name": "question",
                        "type": "string"
                    },
                    {
                        "internalType": "uint256",
                        "name": "startTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "endTime",
                        "type": "uint256"
                    },
                    {
                        "internalType": "bool",
                        "name": "isActive",
                        "type": "bool"
                    },
                    {
                        "internalType": "bool",
                        "name": "isSettled",
                        "type": "bool"
                    },
                    {
                        "internalType": "uint256",
                        "name": "totalVotes",
                        "type": "uint256"
                    },
                    {
                        "internalType": "address",
                        "name": "vault",
                        "type": "address"
                    },
                    {
                        "internalType": "uint256",
                        "name": "winningOption",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "totalStaked",
                        "type": "uint256"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "address",
                        "name": "admin",
                        "type": "address"
                    }
                ],
                "name": "removeAdmin",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "renounceRole",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes32",
                        "name": "role",
                        "type": "bytes32"
                    },
                    {
                        "internalType": "address",
                        "name": "account",
                        "type": "address"
                    }
                ],
                "name": "revokeRole",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    }
                ],
                "name": "settleStakes",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "bytes4",
                        "name": "interfaceId",
                        "type": "bytes4"
                    }
                ],
                "name": "supportsInterface",
                "outputs": [
                    {
                        "internalType": "bool",
                        "name": "",
                        "type": "bool"
                    }
                ],
                "stateMutability": "view",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "string",
                        "name": "_question",
                        "type": "string"
                    }
                ],
                "name": "updateQuestion",
                "outputs": [],
                "stateMutability": "nonpayable",
                "type": "function"
            },
            {
                "inputs": [
                    {
                        "internalType": "uint256",
                        "name": "_questionId",
                        "type": "uint256"
                    },
                    {
                        "internalType": "uint256",
                        "name": "_optionIndex",
                        "type": "uint256"
                    }
                ],
                "name": "vote",
                "outputs": [],
                "stateMutability": "payable",
                "type": "function"
            }
        ];

        // Utility functions
        function addMessage(message, type = 'info') {
            const messagesDiv = document.getElementById('messages');
            const messageDiv = document.createElement('div');
            
            // Apply inline styles based on type
            if (type === 'success') {
                messageDiv.style.color = 'green';
                messageDiv.style.backgroundColor = '#d4edda';
                messageDiv.style.padding = '10px';
                messageDiv.style.borderRadius = '4px';
                messageDiv.style.margin = '5px 0';
            } else if (type === 'error') {
                messageDiv.style.color = 'red';
                messageDiv.style.backgroundColor = '#f8d7da';
                messageDiv.style.padding = '10px';
                messageDiv.style.borderRadius = '4px';
                messageDiv.style.margin = '5px 0';
            } else if (type === 'info') {
                messageDiv.style.color = 'blue';
                messageDiv.style.backgroundColor = '#d1ecf1';
                messageDiv.style.padding = '10px';
                messageDiv.style.borderRadius = '4px';
                messageDiv.style.margin = '5px 0';
            } else if (type === 'warning') {
                messageDiv.style.color = 'orange';
                messageDiv.style.backgroundColor = '#fff3cd';
                messageDiv.style.padding = '10px';
                messageDiv.style.borderRadius = '4px';
                messageDiv.style.margin = '5px 0';
            }
            
            messageDiv.textContent = message;
            messagesDiv.appendChild(messageDiv);
            
            // Auto remove after 10 seconds
            setTimeout(() => {
                if (messageDiv.parentNode) {
                    messageDiv.parentNode.removeChild(messageDiv);
                }
            }, 10000);
        }

        // Connection functions
        async function connectWallet() {
            try {
                if (window.ethereum) {
                    web3 = new Web3(window.ethereum);
                    const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                    currentAccount = accounts[0];
                    document.getElementById('currentAccount').textContent = currentAccount;
                    document.getElementById('connectionStatus').textContent = 'Connected';
                    
                    // Get balance
                    const balance = await web3.eth.getBalance(currentAccount);
                    document.getElementById('accountBalance').textContent = web3.utils.fromWei(balance, 'ether') + ' ETH';
                    
                    addMessage('Wallet connected successfully', 'success');
                    updateBlockchainTime();
                } else {
                    addMessage('No Ethereum wallet found. Please install MetaMask.', 'error');
                }
            } catch (error) {
                console.error('Error connecting wallet:', error);
                addMessage('Error connecting wallet: ' + error.message, 'error');
            }
        }

        async function switchToAnvil() {
            try {
                await window.ethereum.request({
                    method: 'wallet_addEthereumChain',
                    params: [{
                        chainId: '0x7A69',
                        chainName: 'Anvil',
                        nativeCurrency: {
                            name: 'ETH',
                            symbol: 'ETH',
                            decimals: 18,
                        },
                        rpcUrls: ['http://127.0.0.1:8545'],
                    }],
                });
                addMessage('Switched to Anvil network', 'success');
            } catch (error) {
                console.error('Error switching to Anvil:', error);
                addMessage('Error switching to Anvil: ' + error.message, 'error');
            }
        }

        async function updateBlockchainTime() {
            try {
                if (web3) {
                    const block = await web3.eth.getBlock('latest');
                    const timestamp = new Date(block.timestamp * 1000);
                    document.getElementById('blockchainTime').textContent = timestamp.toLocaleString();
                    document.getElementById('currentBlockchainTime').textContent = timestamp.toLocaleString();
                }
            } catch (error) {
                console.error('Error getting blockchain time:', error);
            }
        }

        // Contract initialization
        async function initializeContracts() {
            try {
                const factoryAddr = document.getElementById('factoryAddress').value;
                const votingAddr = document.getElementById('votingAddress').value;
                
                if (!factoryAddr || !votingAddr) {
                    addMessage('Please enter both contract addresses', 'error');
                    return;
                }
                
                if (!web3) {
                    addMessage('Please connect wallet first', 'error');
                    return;
                }
                
                mpTokenFactory = new web3.eth.Contract(MP_TOKEN_FACTORY_ABI, factoryAddr);
                mpVoting = new web3.eth.Contract(MP_VOTING_ABI, votingAddr);
                
                // Get MP Token address
                const mpTokenAddress = await mpTokenFactory.methods.getMPTokenAddress().call();
                
                // Verify contracts
                const factoryAdmin = await mpTokenFactory.methods.isAdmin(currentAccount).call();
                const votingAdmin = await mpVoting.methods.isAdmin(currentAccount).call();
                
                document.getElementById('contractStatus').innerHTML = `
                    <div style="color: green; background: #d4edda; padding: 10px; border-radius: 4px;">Contracts initialized successfully!</div>
                    <div>MP Token Address: ${mpTokenAddress}</div>
                    <div>Factory Admin: ${factoryAdmin ? 'Yes' : 'No'}</div>
                    <div>Voting Admin: ${votingAdmin ? 'Yes' : 'No'}</div>
                `;
                
                updateAdminStatus();
                addMessage('Contracts initialized successfully', 'success');
                
            } catch (error) {
                console.error('Error initializing contracts:', error);
                addMessage('Error initializing contracts: ' + error.message, 'error');
            }
        }

        async function updateAdminStatus() {
            try {
                if (!mpTokenFactory || !mpVoting || !currentAccount) return;
                
                const isFactoryAdmin = await mpTokenFactory.methods.isAdmin(currentAccount).call();
                const isVotingAdmin = await mpVoting.methods.isAdmin(currentAccount).call();
                
                document.getElementById('adminStatus').innerHTML = `
                    <div style="color: blue; background: #d1ecf1; padding: 10px; border-radius: 4px;">
                        <strong>Admin Status:</strong><br>
                        Factory Admin: ${isFactoryAdmin ? ' Yes' : ' No'}<br>
                        Voting Admin: ${isVotingAdmin ? ' Yes' : ' No'}
                    </div>
                `;
            } catch (error) {
                console.error('Error checking admin status:', error);
            }
        }

        // Admin functions
        async function createMPToken() {
            try {
                const recipient = document.getElementById('mpRecipient').value;
                const name = document.getElementById('mpName').value;
                const party = document.getElementById('mpParty').value;
                const constituency = document.getElementById('mpConstituency').value;
                
                if (!recipient || !name || !party || !constituency) {
                    addMessage('Please fill in all fields', 'error');
                    return;
                }
                
                const currentYear = new Date().getFullYear();
                const expirationDate = Math.floor(Date.now() / 1000) + (4 * 365 * 24 * 60 * 60); // 4 years from now
                
                addMessage('Creating MP Token...', 'info');
                
                const receipt = await mpTokenFactory.methods.createMPToken(
                    recipient,
                    name,
                    party,
                    constituency,
                    currentYear,
                    expirationDate
                ).send({
                    from: currentAccount,
                    gas: 500000
                });
                
                addMessage(`MP Token created successfully! Transaction: ${receipt.transactionHash}`, 'success');
                
                // Clear form
                document.getElementById('mpRecipient').value = '';
                document.getElementById('mpName').value = '';
                document.getElementById('mpParty').value = '';
                document.getElementById('mpConstituency').value = '';
                
            } catch (error) {
                console.error('Error creating MP token:', error);
                addMessage('Error creating MP token: ' + error.message, 'error');
            }
        }

        // Check if a token is expired
        async function checkTokenExpiry() {
            const tokenId = document.getElementById('tokenIdToDestroy').value;
            const statusDiv = document.getElementById('tokenExpiryStatus');
            
            if (!tokenId) {
                statusDiv.innerHTML = '<span style="color: red;">Please enter a token ID</span>';
                return;
            }

            try {
                if (!mpTokenFactory) {
                    statusDiv.innerHTML = '<span style="color: red;">Please initialize contracts first</span>';
                    return;
                }

                // Get token data
                const tokenData = await mpTokenFactory.methods.getMPTokenData(tokenId).call();
                const isExpired = await mpTokenFactory.methods.isTokenExpired(tokenId).call();
                const currentTime = Math.floor(Date.now() / 1000);
                const expirationDate = new Date(tokenData.expirationDate * 1000);

                statusDiv.innerHTML = `
                    <strong>Token #${tokenId} Status:</strong><br>
                    Name: ${tokenData.name}<br>
                    Party: ${tokenData.party}<br>
                    Constituency: ${tokenData.constituency}<br>
                    Active: ${tokenData.isActive ? 'Yes' : 'No'}<br>
                    Expiration Date: ${expirationDate.toLocaleString()}<br>
                    <span style="color: ${isExpired ? 'red' : 'green'};">
                        Status: ${isExpired ? 'EXPIRED - Can be destroyed' : 'NOT EXPIRED - Cannot be destroyed yet'}
                    </span>
                `;
            } catch (error) {
                console.error('Error checking token expiry:', error);
                statusDiv.innerHTML = `<span style="color: red;">Error: ${error.message}</span>`;
            }
        }

        // Destroy an expired MP token
        async function destroyExpiredToken() {
            const tokenId = document.getElementById('tokenIdToDestroy').value;
            const statusDiv = document.getElementById('tokenExpiryStatus');
            
            if (!tokenId) {
                addMessage('Please enter a token ID', 'error');
                return;
            }

            try {
                if (!mpTokenFactory || !currentAccount) {
                    addMessage('Please connect wallet and initialize contracts first', 'error');
                    return;
                }

                // First check if token is expired
                const isExpired = await mpTokenFactory.methods.isTokenExpired(tokenId).call();
                if (!isExpired) {
                    addMessage('Token has not expired yet and cannot be destroyed', 'error');
                    return;
                }

                // Check if user is admin
                const isAdmin = await mpTokenFactory.methods.isAdmin(currentAccount).call();
                if (!isAdmin) {
                    addMessage('Only admins can destroy expired tokens', 'error');
                    return;
                }

                addMessage('Destroying expired token...', 'info');

                // Destroy the expired token
                const receipt = await mpTokenFactory.methods.destroyExpiredMPToken(tokenId).send({
                    from: currentAccount,
                    gas: 200000
                });

                addMessage(`Successfully destroyed expired token #${tokenId}. Transaction: ${receipt.transactionHash}`, 'success');
                statusDiv.innerHTML = '<span style="color: green;">Token destroyed successfully!</span>';
                
                // Clear the input
                document.getElementById('tokenIdToDestroy').value = '';
                
            } catch (error) {
                console.error('Error destroying token:', error);
                addMessage(`Error destroying token: ${error.message}`, 'error');
            }
        }

        // Update MP Token Status (Active/Inactive)
        async function updateMPTokenStatus() {
            const tokenId = document.getElementById('tokenIdToUpdate').value;
            const isActive = document.getElementById('tokenStatus').value === 'true';
            
            if (!tokenId) {
                addMessage('Please enter a token ID', 'error');
                return;
            }

            try {
                if (!mpTokenFactory || !currentAccount) {
                    addMessage('Please connect wallet and initialize contracts first', 'error');
                    return;
                }

                // Check if user is admin
                const isAdmin = await mpTokenFactory.methods.isAdmin(currentAccount).call();
                if (!isAdmin) {
                    addMessage('Only admins can update token status', 'error');
                    return;
                }

                addMessage(`Updating token #${tokenId} status to ${isActive ? 'Active' : 'Inactive'}...`, 'info');

                // Update token status
                const receipt = await mpTokenFactory.methods.updateMPTokenStatus(tokenId, isActive).send({
                    from: currentAccount,
                    gas: 100000
                });

                addMessage(`Successfully updated token #${tokenId} status. Transaction: ${receipt.transactionHash}`, 'success');
                
                // Clear the input
                document.getElementById('tokenIdToUpdate').value = '';
                
            } catch (error) {
                console.error('Error updating token status:', error);
                addMessage(`Error updating token status: ${error.message}`, 'error');
            }
        }

        function setStartTimeNow() {
            const now = new Date();
            now.setMinutes(now.getMinutes() + 2); // Add 2 minutes
            document.getElementById('startTime').value = now.toISOString().slice(0, 16);
        }

        function setEndTime() {
            const startTime = document.getElementById('startTime').value;
            if (startTime) {
                const start = new Date(startTime);
                start.setMinutes(start.getMinutes() + 10);
                document.getElementById('endTime').value = start.toISOString().slice(0, 16);
            }
        }

        async function getBlockchainTimestamp() {
            try {
                if (web3) {
                    const block = await web3.eth.getBlock('latest');
                    const timestamp = new Date(block.timestamp * 1000);
                    document.getElementById('currentBlockchainTime').textContent = timestamp.toLocaleString();
                    return block.timestamp;
                }
            } catch (error) {
                console.error('Error getting blockchain timestamp:', error);
                return null;
            }
        }

        function testTimeValidation() {
            const startTime = document.getElementById('startTime').value;
            const endTime = document.getElementById('endTime').value;
            
            if (!startTime || !endTime) {
                addMessage('Please set both start and end times first', 'warning');
                return;
            }
            
            const start = new Date(startTime).getTime() / 1000;
            const end = new Date(endTime).getTime() / 1000;
            const now = Math.floor(Date.now() / 1000);
            
            addMessage(`Time validation:
                Start: ${new Date(start * 1000).toLocaleString()}
                End: ${new Date(end * 1000).toLocaleString()}
                Now: ${new Date(now * 1000).toLocaleString()}
                Start > Now: ${start > now}
                End > Start: ${end > start}`, 'info');
        }

        async function createQuestion() {
            try {
                const question = document.getElementById('questionText').value;
                const startTime = document.getElementById('startTime').value;
                const endTime = document.getElementById('endTime').value;
                
                if (!question || !startTime || !endTime) {
                    addMessage('Please fill in all fields', 'error');
                    return;
                }
                
                const startTimestamp = Math.floor(new Date(startTime).getTime() / 1000);
                const endTimestamp = Math.floor(new Date(endTime).getTime() / 1000);
                
                addMessage('Creating question...', 'info');
                
                const receipt = await mpVoting.methods.createQuestion(
                    question,
                    startTimestamp,
                    endTimestamp
                ).send({
                    from: currentAccount,
                    gas: 500000
                });
                
                addMessage(`Question created successfully! Transaction: ${receipt.transactionHash}`, 'success');
                
                // Clear form
                document.getElementById('questionText').value = '';
                document.getElementById('startTime').value = '';
                document.getElementById('endTime').value = '';
                
            } catch (error) {
                console.error('Error creating question:', error);
                addMessage('Error creating question: ' + error.message, 'error');
            }
        }

        async function closeQuestion() {
            try {
                const questionId = document.getElementById('questionIdToClose').value;
                
                if (!questionId) {
                    addMessage('Please enter a question ID', 'error');
                    return;
                }
                
                addMessage('Closing question...', 'info');
                
                const receipt = await mpVoting.methods.closeQuestion(questionId).send({
                    from: currentAccount,
                    gas: 300000
                });
                
                addMessage(`Question closed successfully! Transaction: ${receipt.transactionHash}`, 'success');
                
            } catch (error) {
                console.error('Error closing question:', error);
                addMessage('Error closing question: ' + error.message, 'error');
            }
        }

        async function settleStakes() {
            try {
                const questionId = document.getElementById('questionIdToClose').value;
                
                if (!questionId) {
                    addMessage('Please enter a question ID', 'error');
                    return;
                }
                
                addMessage('Settling stakes...', 'info');
                
                const receipt = await mpVoting.methods.settleStakes(questionId).send({
                    from: currentAccount,
                    gas: 500000
                });
                
                addMessage(`Stakes settled successfully! Transaction: ${receipt.transactionHash}`, 'success');
                
            } catch (error) {
                console.error('Error settling stakes:', error);
                addMessage('Error settling stakes: ' + error.message, 'error');
            }
        }

        async function addAdmin() {
            try {
                const adminAddress = document.getElementById('adminAddress').value;
                
                if (!adminAddress) {
                    addMessage('Please enter an admin address', 'error');
                    return;
                }
                
                addMessage('Adding admin...', 'info');
                
                const receipt1 = await mpTokenFactory.methods.addAdmin(adminAddress).send({
                    from: currentAccount,
                    gas: 200000
                });
                
                const receipt2 = await mpVoting.methods.addAdmin(adminAddress).send({
                    from: currentAccount,
                    gas: 200000
                });
                
                addMessage(`Admin added successfully to both contracts! Transactions: ${receipt1.transactionHash}, ${receipt2.transactionHash}`, 'success');
                
                document.getElementById('adminAddress').value = '';
                updateAdminStatus();
                
            } catch (error) {
                console.error('Error adding admin:', error);
                addMessage('Error adding admin: ' + error.message, 'error');
            }
        }

        async function removeAdmin() {
            try {
                const adminAddress = document.getElementById('adminAddress').value;
                
                if (!adminAddress) {
                    addMessage('Please enter an admin address', 'error');
                    return;
                }
                
                addMessage('Removing admin...', 'info');
                
                const receipt1 = await mpTokenFactory.methods.removeAdmin(adminAddress).send({
                    from: currentAccount,
                    gas: 200000
                });
                
                const receipt2 = await mpVoting.methods.removeAdmin(adminAddress).send({
                    from: currentAccount,
                    gas: 200000
                });
                
                addMessage(`Admin removed successfully from both contracts! Transactions: ${receipt1.transactionHash}, ${receipt2.transactionHash}`, 'success');
                
                document.getElementById('adminAddress').value = '';
                updateAdminStatus();
                
            } catch (error) {
                console.error('Error removing admin:', error);
                addMessage('Error removing admin: ' + error.message, 'error');
            }
        }

        // MP Dashboard functions
        async function loadMPTokens() {
            try {
                if (!mpTokenFactory || !currentAccount) {
                    addMessage('Please connect wallet and initialize contracts first', 'error');
                    return;
                }
                
                const mpTokenAddress = await mpTokenFactory.methods.getMPTokenAddress().call();
                mpToken = new web3.eth.Contract([
                    {
                        "inputs": [{"internalType": "address", "name": "owner", "type": "address"}],
                        "name": "balanceOf",
                        "outputs": [{"internalType": "uint256", "name": "", "type": "uint256"}],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ], mpTokenAddress);
                
                const balance = await mpToken.methods.balanceOf(currentAccount).call();
                const totalMPs = await mpTokenFactory.methods.getMPTokenCount().call();
                
                let myTokens = [];
                
                // Check each token to see if we own it
                for (let i = 1; i <= totalMPs; i++) {
                    try {
                        const tokenData = await mpTokenFactory.methods.getMPTokenData(i).call();
                        const owner = await mpToken.methods.ownerOf(i).call();
                        
                        if (owner.toLowerCase() === currentAccount.toLowerCase()) {
                            const isExpired = await mpTokenFactory.methods.isTokenExpired(i).call();
                            myTokens.push({
                                id: i,
                                data: tokenData,
                                isExpired: isExpired
                            });
                        }
                    } catch (error) {
                        // Token might not exist or be burned, skip
                        continue;
                    }
                }
                
                let html = `<div style="color: blue; background: #d1ecf1; padding: 10px; border-radius: 4px;">You own ${myTokens.length} MP tokens out of ${balance} total</div>`;
                
                if (myTokens.length > 0) {
                    html += '<div>';
                    myTokens.forEach(token => {
                        const expDate = new Date(token.data.expirationDate * 1000);
                        html += `
                            <div style="border: 1px solid #ddd; margin: 10px 0; padding: 10px; border-radius: 4px;">
                                <strong>Token #${token.id}</strong><br>
                                Name: ${token.data.name}<br>
                                Party: ${token.data.party}<br>
                                Constituency: ${token.data.constituency}<br>
                                Election Year: ${token.data.electionYear}<br>
                                Status: <span style="color: ${token.data.isActive ? 'green' : 'red'}">${token.data.isActive ? 'Active' : 'Inactive'}</span><br>
                                Expires: ${expDate.toLocaleString()} 
                                <span style="color: ${token.isExpired ? 'red' : 'green'}">(${token.isExpired ? 'EXPIRED' : 'Valid'})</span>
                            </div>
                        `;
                    });
                    html += '</div>';
                } else {
                    html += '<div>You do not own any MP tokens.</div>';
                }
                
                document.getElementById('myMPTokens').innerHTML = html;
                
                // Update MP status
                const isValidVoter = await mpVoting.methods.isValidMPVoter(currentAccount).call();
                document.getElementById('mpStatus').innerHTML = `
                    <div style="color: ${isValidVoter ? 'green' : 'orange'}; background: ${isValidVoter ? '#d4edda' : '#fff3cd'}; padding: 10px; border-radius: 4px;">
                        Voting Eligibility: ${isValidVoter ? ' Eligible to vote' : ' Not eligible to vote'}
                    </div>
                `;
                
            } catch (error) {
                console.error('Error loading MP tokens:', error);
                addMessage('Error loading MP tokens: ' + error.message, 'error');
            }
        }

        // Voting functions
        async function loadActiveQuestions() {
            try {
                if (!mpVoting) {
                    addMessage('Please initialize contracts first', 'error');
                    return;
                }
                
                const questionCount = await mpVoting.methods.questionCount().call();
                let html = '';
                
                for (let i = 1; i <= questionCount; i++) {
                    try {
                        const details = await mpVoting.methods.getQuestionDetails(i).call();
                        const now = Math.floor(Date.now() / 1000);
                        
                        if (details.isActive && details.startTime <= now && details.endTime >= now) {
                            const hasVoted = await mpVoting.methods.checkVote(i, currentAccount).call();
                            const stakeInfo = await mpVoting.methods.getStakeInfo(i, currentAccount).call();
                            
                            html += `
                                <div style="border: 2px solid #007bff; margin: 15px 0; padding: 15px; border-radius: 8px; background-color: #f8f9fa;">
                                    <h4>Question #${i}: ${details.question}</h4>
                                    <div><strong>Start:</strong> ${new Date(details.startTime * 1000).toLocaleString()}</div>
                                    <div><strong>End:</strong> ${new Date(details.endTime * 1000).toLocaleString()}</div>
                                    <div><strong>Total Votes:</strong> ${details.totalVotes}</div>
                                    <div><strong>Total Staked:</strong> ${web3.utils.fromWei(details.totalStaked, 'ether')} ETH</div>
                                    <div><strong>Vault Owner:</strong> ${details.vault}</div>
                                    <div><strong>Required Stake:</strong> 100 ETH per vote</div>
                                    
                                    ${hasVoted.hasVoted ? 
                                        `<div style="color: green; background: #d4edda; padding: 10px; border-radius: 4px;"> You voted: ${['Yes', 'No', 'Abstain'][hasVoted.optionIndex]} (Staked: ${web3.utils.fromWei(stakeInfo.staked, 'ether')} ETH)</div>` :
                                        `<div style="margin: 10px 0;">
                                            <button onclick="voteOnQuestion(${i}, 0)" style="background: green;">Vote Yes (100 ETH)</button>
                                            <button onclick="voteOnQuestion(${i}, 1)" style="background: red;">Vote No (100 ETH)</button>
                                            <button onclick="voteOnQuestion(${i}, 2)" style="background: gray;">Abstain (100 ETH)</button>
                                        </div>`
                                    }
                                </div>
                            `;
                        }
                    } catch (error) {
                        console.error(`Error loading question ${i}:`, error);
                    }
                }
                
                if (!html) {
                    html = '<div style="color: blue; background: #d1ecf1; padding: 10px; border-radius: 4px;">No active questions available for voting.</div>';
                }
                
                document.getElementById('activeQuestions').innerHTML = html;
                
            } catch (error) {
                console.error('Error loading active questions:', error);
                addMessage('Error loading active questions: ' + error.message, 'error');
            }
        }

        async function voteOnQuestion(questionId, optionIndex) {
            try {
                if (!mpVoting || !currentAccount) {
                    addMessage('Please connect wallet and initialize contracts first', 'error');
                    return;
                }
                
                const isValidVoter = await mpVoting.methods.isValidMPVoter(currentAccount).call();
                if (!isValidVoter) {
                    addMessage('You are not eligible to vote. You need an active, non-expired MP token.', 'error');
                    return;
                }
                
                const optionNames = ['Yes', 'No', 'Abstain'];
                addMessage(`Voting ${optionNames[optionIndex]} on question ${questionId} with 100 ETH stake...`, 'info');
                
                const receipt = await mpVoting.methods.vote(questionId, optionIndex).send({
                    from: currentAccount,
                    value: web3.utils.toWei('100', 'ether'),
                    gas: 300000
                });
                
                addMessage(`Vote cast successfully! You voted ${optionNames[optionIndex]} and staked 100 ETH. Transaction: ${receipt.transactionHash}`, 'success');
                
                // Reload questions to show updated status
                loadActiveQuestions();
                
            } catch (error) {
                console.error('Error voting:', error);
                addMessage('Error voting: ' + error.message, 'error');
            }
        }

        // Stake management
        async function loadMyStakes() {
            try {
                if (!mpVoting || !currentAccount) {
                    addMessage('Please connect wallet and initialize contracts first', 'error');
                    return;
                }
                
                const questionCount = await mpVoting.methods.questionCount().call();
                let html = '<div><h3>My Stakes</h3>';
                let hasStakes = false;
                
                for (let i = 1; i <= questionCount; i++) {
                    try {
                        const stakeInfo = await mpVoting.methods.getStakeInfo(i, currentAccount).call();
                        
                        if (parseInt(stakeInfo.staked) > 0) {
                            hasStakes = true;
                            const details = await mpVoting.methods.getQuestionDetails(i).call();
                            const voteCheck = await mpVoting.methods.checkVote(i, currentAccount).call();
                            
                            html += `
                                <div style="border: 1px solid #ddd; margin: 10px 0; padding: 15px; border-radius: 6px;">
                                    <h4>Question #${i}</h4>
                                    <div><strong>Question:</strong> ${details.question}</div>
                                    <div><strong>Your Vote:</strong> ${['Yes', 'No', 'Abstain'][voteCheck.optionIndex]}</div>
                                    <div><strong>Staked Amount:</strong> ${web3.utils.fromWei(stakeInfo.staked, 'ether')} ETH</div>
                                    <div><strong>Stake Returned:</strong> ${stakeInfo.returned ? 'Yes' : 'No'}</div>
                                    <div><strong>Can Claim:</strong> ${stakeInfo.canClaim ? 'Yes' : 'No'}</div>
                                    <div><strong>Question Status:</strong> ${details.isActive ? 'Active' : 'Closed'}</div>
                                    
                                    ${stakeInfo.canClaim ? 
                                        `<button onclick="claimStake(${i})" style="background: green; margin-top: 10px;">Claim Stake</button>` :
                                        '<div style="color: gray; margin-top: 10px;">Cannot claim yet (voting still active or already claimed)</div>'
                                    }
                                </div>
                            `;
                        }
                    } catch (error) {
                        console.error(`Error checking stakes for question ${i}:`, error);
                    }
                }
                
                html += '</div>';
                
                if (!hasStakes) {
                    html = '<div style="color: blue; background: #d1ecf1; padding: 10px; border-radius: 4px;">You have no stakes in any voting questions.</div>';
                }
                
                document.getElementById('myStakes').innerHTML = html;
                
            } catch (error) {
                console.error('Error loading stakes:', error);
                addMessage('Error loading stakes: ' + error.message, 'error');
            }
        }

        async function claimStake(questionId) {
            try {
                if (!mpVoting || !currentAccount) {
                    addMessage('Please connect wallet and initialize contracts first', 'error');
                    return;
                }
                
                addMessage(`Claiming stake for question ${questionId}...`, 'info');
                
                const receipt = await mpVoting.methods.claimStake(questionId).send({
                    from: currentAccount,
                    gas: 300000
                });
                
                addMessage(`Stake claimed successfully! Transaction: ${receipt.transactionHash}`, 'success');
                
                // Reload stakes to show updated status
                loadMyStakes();
                
                // Update balance
                const balance = await web3.eth.getBalance(currentAccount);
                document.getElementById('accountBalance').textContent = web3.utils.fromWei(balance, 'ether') + ' ETH';
                
            } catch (error) {
                console.error('Error claiming stake:', error);
                addMessage('Error claiming stake: ' + error.message, 'error');
            }
        }

        // Load all questions (results and history)
        async function loadAllQuestions() {
            try {
                if (!mpVoting) {
                    addMessage('Please initialize contracts first', 'error');
                    return;
                }
                
                const questionCount = await mpVoting.methods.questionCount().call();
                let html = '<div><h3>All Questions & Results</h3>';
                
                for (let i = 1; i <= questionCount; i++) {
                    try {
                        const details = await mpVoting.methods.getQuestionDetails(i).call();
                        const voteCounts = await mpVoting.methods.getAllVoteCounts(i).call();
                        
                        const statusColor = details.isActive ? '#007bff' : '#6c757d';
                        const statusText = details.isActive ? 'Active' : 'Closed';
                        
                        html += `
                            <div style="border: 2px solid ${statusColor}; margin: 15px 0; padding: 15px; border-radius: 8px;">
                                <h4>Question #${i}: ${details.question}</h4>
                                <div><strong>Status:</strong> <span style="color: ${statusColor};">${statusText}</span></div>
                                <div><strong>Start:</strong> ${new Date(details.startTime * 1000).toLocaleString()}</div>
                                <div><strong>End:</strong> ${new Date(details.endTime * 1000).toLocaleString()}</div>
                                <div><strong>Total Votes:</strong> ${details.totalVotes}</div>
                                <div><strong>Total Staked:</strong> ${web3.utils.fromWei(details.totalStaked, 'ether')} ETH</div>
                                <div><strong>Vault Owner:</strong> ${details.vault}</div>
                                
                                <div style="margin: 10px 0;">
                                    <strong>Vote Results:</strong><br>
                                    Yes: ${voteCounts[0]} votes<br>
                                    No: ${voteCounts[1]} votes<br>
                                    Abstain: ${voteCounts[2]} votes
                                </div>
                                
                                ${!details.isActive && details.totalVotes > 0 ? 
                                    `<div><strong>Winner:</strong> ${['Yes', 'No', 'Abstain'][details.winningOption]}</div>` :
                                    ''
                                }
                            </div>
                        `;
                    } catch (error) {
                        console.error(`Error loading question ${i}:`, error);
                    }
                }
                
                html += '</div>';
                document.getElementById('allQuestions').innerHTML = html;
                
            } catch (error) {
                console.error('Error loading all questions:', error);
                addMessage('Error loading all questions: ' + error.message, 'error');
            }
        }

        // Load all MPs
        async function loadAllMPs() {
            try {
                if (!mpTokenFactory) {
                    addMessage('Please initialize contracts first', 'error');
                    return;
                }
                
                const totalMPs = await mpTokenFactory.methods.getMPTokenCount().call();
                const mpTokenAddress = await mpTokenFactory.methods.getMPTokenAddress().call();
                
                // Initialize MP Token contract for ownerOf calls
                const mpTokenContract = new web3.eth.Contract([
                    {
                        "inputs": [{"internalType": "uint256", "name": "tokenId", "type": "uint256"}],
                        "name": "ownerOf",
                        "outputs": [{"internalType": "address", "name": "", "type": "address"}],
                        "stateMutability": "view",
                        "type": "function"
                    }
                ], mpTokenAddress);
                
                let html = `<div><h3>All MPs Directory (${totalMPs} total)</h3>`;
                
                for (let i = 1; i <= totalMPs; i++) {
                    try {
                        const tokenData = await mpTokenFactory.methods.getMPTokenData(i).call();
                        const owner = await mpTokenContract.methods.ownerOf(i).call();
                        const isExpired = await mpTokenFactory.methods.isTokenExpired(i).call();
                        
                        const expDate = new Date(tokenData.expirationDate * 1000);
                        
                        html += `
                            <div style="border: 1px solid #ddd; margin: 10px 0; padding: 10px; border-radius: 4px; ${isExpired ? 'background-color: #f8f8f8;' : ''}">
                                <strong>Token #${i}: ${tokenData.name}</strong><br>
                                Party: ${tokenData.party}<br>
                                Constituency: ${tokenData.constituency}<br>
                                Election Year: ${tokenData.electionYear}<br>
                                Owner: ${owner}<br>
                                Status: <span style="color: ${tokenData.isActive ? 'green' : 'red'}">${tokenData.isActive ? 'Active' : 'Inactive'}</span><br>
                                Expires: ${expDate.toLocaleString()} 
                                <span style="color: ${isExpired ? 'red' : 'green'}">(${isExpired ? 'EXPIRED' : 'Valid'})</span>
                            </div>
                        `;
                    } catch (error) {
                        // Token might be burned, show as destroyed
                        html += `
                            <div style="border: 1px solid #ccc; margin: 10px 0; padding: 10px; border-radius: 4px; background-color: #f0f0f0; color: #666;">
                                <strong>Token #${i}: [DESTROYED]</strong><br>
                                This token has been burned/destroyed.
                            </div>
                        `;
                    }
                }
                
                html += '</div>';
                document.getElementById('allMPs').innerHTML = html;
                
            } catch (error) {
                console.error('Error loading all MPs:', error);
                addMessage('Error loading all MPs: ' + error.message, 'error');
            }
        }

        // Initialize page
        window.onload = function() {
            updateBlockchainTime();
            setInterval(updateBlockchainTime, 30000); // Update every 30 seconds
        };
    </script>
</body>
</html>
